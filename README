django_safeform
===============

CSRF protection for Django implemented at the form level - no middleware 
required.

There are two steps to protecting a django.forms form:

1. Wrap it with the SafeForm class decorator. This adds a hidden csrf_token 
   field to it along with validation logic for checking if that token has 
   the correct value. It also changes the signature of the form class 
   slightly, see example below.
2. Apply the @csrf_protect middleware to the view containing the form. This 
   ensures that a _csrf_cookie is correctly set.

Example usage
-------------

    from django import forms
    from django.http import HttpResponse
    from django.shortcuts import render_to_response
    from django_safeform import SafeForm, csrf_protect
    
    class ChangePasswordForm(forms.Form):
        password = forms.CharField(widget = forms.PasswordInput)
        password2 = forms.CharField(widget = forms.PasswordInput)
    
    ChangePasswordForm = SafeForm(ChangePasswordForm)
    
    @csrf_protect
    def change_password(request):
        form = ChangePasswordForm(request) # A
        if form.is_valid(): # B
            # ... change the user's password here
            return HttpResponse('Thank you')
        return render_to_response('change_password.html', {
            'form': form,
        })

A: Note that we pass the whole request object to the constructor, instead of
   just passing request.POST.

B: A pleasant side-effect of SafeForm is that you no longer need to check to 
   see if request.method == 'POST' - SafeForm handles this for you.

Custom form templates
---------------------

If your template uses one of the form rendering helper methods such as 
{{ form.as_p }} the hidden csrf_token field will be output automatically. If 
you are rendering the form using a custom template you will need to remember 
to output that field in your template explicitly. Here's an example:

    <form action="/change-password/" method="post">
        {{ form.non_field_errors }}
        <div{% if form.password.errors %} class="errors"{% endif %}>
            <label for="id_password">New password</label>
            {{ form.password }}
        </div>
        <div{% if form.password2.errors %} class="errors"{% endif %}>
            <label for="id_password2">Confirm password</label>
            {{ form.password2 }}
        </div>
        <div>{{ form.csrf_token }}<input type="submit" value="Change"></div>
    </form>

Note the {{ form.csrf_token }} replacement variable just before the submit 
button - this will output a hidden form field containing the correct value.

You should also be sure to include {{ form.non_field_errors }} somewhere in 
your template - this is where the "Form session expired - please resubmit" 
message will be displayed should the CSRF check fail for some reason.

Protecting forms that do not use django.forms
---------------------------------------------

If you are not using the django.forms framework - for example you are writing 
forms with hand-written HTML and pulling submitted data directly from 
request.POST - you can still add CSRF protection to your forms using the 
@csrf_protect decorator in conjunction with the csrf_utils module:

    from django_safeform import csrf_protect, csrf_utils
    
    @csrf_protect
    def hand_rolled(request):
        if request.method == 'POST':
            csrf_token = request.POST.get('csrf_token', '')
            if not csrf_utils.validate_csrf_token(csrf_token, request):
                return HttpResponse('Invalid CSRF token')
            else:
                return HttpResponse('OK')
        else:
            return HttpResponse("""
            <form action="." method="post">
            <input type="text" name="name">
            <input type="hidden" name="csrf_token" value="%s">
            </form>
            """ % csrf_utils.new_csrf_token(request))

It is your responsibility to include a hidden form field with the value from 
csrf_utils.new_csrf_token(request) in your form, and to check that token when 
the form is submitted using csrf_utils.validate_csrf_token.

Extra options
-------------

The default message shown to the user if the CSRF check fails is:

    Form session expired - please resubmit

The wording here is deliberately a bit vague - most users will have no idea 
what a "CSRF failure" is, but users have probably seen "session expired" 
messages before. A "form session" seems like a reasonable metaphor for what 
is going on under the hood.

If you dislike this message, you can over-ride it in your call to the 
SafeForm class decorator:

    ChangePasswordForm = SafeForm(ChangePasswordForm,
        invalid_message='CSRF check failed'
    )

Design notes
------------

Apps shipped with Django, in particular the admin, MUST be secure against CSRF 
no matter what the user's configuration is (so dependency on middleware alone 
is a problem).

Secure by default for user code would be nice, but in its absence explicitly 
raising developer awareness of CSRF is probably a good thing.

Should not be tied to sessions - some developers might not be using them.

Should not require the form framework - hand-rolled forms should be easy to 
protect too.

The original idea was to have an alternative Form base class called SafeForm - 
this was replaced with a class decorator when we realised that we would 
otherwise also need to provide SafeModelForm, SafeFormSet and so on.

Todo
----

* Create CsrfForm, for use with FormSets / other multi-form scenarios
* Come up with a solution for Ajax requests (request.is_ajax())
* Mega paranoid users should be able to turn Ajax protection off?

Alternative approaches
----------------------

Pure middleware:
- breaks with etags
- rewrites HTML
- doesn't work with streaming
- you have to decorate things as exempt
- potential leakage of external forms
- XHTML v.s. HTML

Middleware and template tags and RequestContext:
- uses a view decorator
- applying by default is error prone
- if user disables middleware, admin becomes insecure
